---
title: echo コマンドの違いと移植性の問題 - 拡張 POSIX シェルスクリプト Advent Calendar 2013
tags: [sh, shell]
layout: default
---

[拡張 POSIX シェルスクリプト Advent Calendar 2013]
(http://www.adventar.org/calendars/212)、8日目の記事です。

今日はシェルや OS ごとに微妙に異なる `echo` コマンドの違いを紹介します。
`echo` コマンドの挙動は大きく分けて 2種類あります。

BSD 系 `echo` コマンドの挙動
----------------------------------------------------------------------

引数に指定された文字列をそのまま出力します。
複数の文字列を指定された場合はスペース (0x20) 一文字で区切られます。

最後に改行を出力しますが、最初の引数が `-n` のときはオプションとして認識し、
最後の改行を出力しません。

``` console
$ echo foo
foo
$ echo foo bar
foo bar
$ echo 'foo\nbar'
foo\nbar
$ echo foo; echo bar
foo
bar
$ echo -n foo; echo bar
foobar
$ echo 'foo\c'; echo bar
foo\c
bar
```

これに該当するのは bash、zsh (`set -o BSD_ECHO` 時) の組込み `echo`、
各種 Linux (GNU coreutils) や BSD 系 OS などの `/bin/echo` です。

`echo` コマンドの実装に依っては `-e` オプションを持つものがあります。
これを指定した場合、文字列に含まれる各種エスケープシーケンスを解釈してから出力します。
(bash、GNU coreutils)

System V 系 `echo` コマンドの挙動
----------------------------------------------------------------------

引数に指定された文字列に含まれるエスケープシーケンスを解釈してから出力します。
複数の文字列を指定された場合はスペース (0x20) 一文字で区切られます。

最後に改行を出力します。
改行を抑制するオプションはありませんが、文字列に
エスケープシーケンス `\c` が含まれている場合は改行は出力しません。

``` console
$ echo foo
foo
echo foo bar
foo bar
$ echo 'foo\nbar'
foo
bar
$ echo foo; echo bar
foo
bar
$ echo -n foo; echo bar
-n foo
bar
$ echo 'foo\c'; echo bar
foobar
```

これに該当するのは zsh (デフォルトの `set +o BSD_ECHO` 時) の組込み `echo`、
Solaris (System V 系の OS 各種) や AIX などの `/bin/echo` です。

zsh の組込み `echo` は特殊で `-n` オプション(改行の抑制)と
`-E` オプション(エスケープ文字の解釈の抑制)にも対応しています。

ksh の組込み `echo`
----------------------------------------------------------------------

ksh は特殊で、仕様は動作する OS の `/bin/echo` と同じになります。
このため、`echo` を利用している ksh スクリプトはポータビリティの問題が生じる可能性があります。

csh の組込み `echo`
----------------------------------------------------------------------

csh? いえ、知らない子ですね。

ポータビリティ対策
----------------------------------------------------------------------

シェルや OS の違いに依らないポータビリティ(移植性、可搬性)
の高いシェルスクリプトを書くには、ポータビリティに問題がある
`echo` を利用してはいけません。代わりに `printf` を利用しましょう。

BSD 系の `echo` は `printf` で簡単に模倣することができます。
普段 BSD 系 `echo` に慣れている、かつ `-e` オプションを利用していないなら、
これを利用するのもありでしょう。

``` sh
echo() {
  if [[ $1 = -n ]]; then
    shift
    printf '%s' "$*"
  else
    printf '%s\n' "$*"
  fi
}
```

`echo` と違い、`printf` コマンドの第一引数は `%`
によるフォーマット指定を解釈する点に注意してください。
スクリプト外部から得た文字列をそのまま第一引数に含めてしまうと、
フォーマット文字列攻撃を受ける可能性があります。

エスケープシーケンス
----------------------------------------------------------------------

ついでに System V 系 `echo` または `-e` オプション対応の BSD 系 `echo`
のエスケープシーケンスを紹介しておきます。

  * `\a`
    * 警告文字 (ベル、0x07)
  * `\b`
    * バックスペース (0x08)
  * `\c`
    * 改行の抑制
    * 実装に依ってはこれ以降の文字列を無視するため、最後に含めるのが無難。
  * `\e`
    * エスケープ文字 (0x1B)
  * `\E`
    * エスケープ文字 (0x1B)
    * bash 組込み `echo` 依存。
  * `\f`
    * 用紙送り文字 (フォームフィード、0x0C)
  * `\n`
    * 改行文字 (LF、0x0A)
  * `\r`
    * 復帰文字 (CR、0x0D)
  * `\t`
    * 水平タブ (0x09)
  * `\v`
    * 垂直タブ (0x0B)
  * `\\`
    * バックスラッシュ (0x5C)
  * `\0`
    * ヌル文字 (NULL, 0x00)
  * `\0NNN`
    * 8 進数 1〜3桁の 1バイトコード
  * `\xNN`
    * 16 進数 1〜2桁の 1バイトコード
  * `\uNNNN`
    * 16 進数 1〜4桁のユニコード 1文字のコード
    * bash, zsh 組込み `echo` 依存。
  * `\UNNNNNNNN`
    * 16 進数 1〜8桁のユニコード 1文字のコード
    * bash, zsh 組込み `echo` 依存。

* * *

{% include wishlist-dec.html %}

