---
title: シェルが怖いなら使わなければいいじゃない - 拡張 POSIX シェルスクリプト Advent Calendar 2013
tags: [sh, shell]
layout: default
---

[拡張 POSIX シェルスクリプト Advent Calendar 2013]
(http://www.adventar.org/calendars/212)、21日目の記事です。
今日は、一部界隈に「シェル怖い」と感じてながら仕方なく使用している人や、
怖さを認識せず(できず?)に平気で使用している人が世に溢れているようなので、
シェルを避ける方法について紹介したいと思います。

***まだ執筆途中。すみません、間に合いませんでした***

あるプログラムから別のプログラムを起動する際、
プログラマーが意図してか意図せずかはさておき、
シェルが介在する場合があります。そこには様々な危険があります。
シェルをよく理解しうまく危険を回避するか、
理解できない/理解したくない/理解する必要がないならシェルを避けるべきです。

…

えー、3日前からチマチマ書き始めて、今現在 2013年12月21日の 15時。
まだ未完成で鋭意執筆中。仕上げる前に Twitter の TL でも消化するかなー。

おや? TL の様子が…。

「PHPだってシェル経由でないコマンド呼び出し機能が欲しい | 徳丸浩の日記」
----------------------------------------------------------------------

https://twitter.com/ockeghem/status/414254447280148480

> 日記書いた>『このエントリはPHP Advent Calendar 2013 in Adventar の21日目です…』
> PHPだってシェル経由でないコマンド呼び出し機能が欲しい |
> 徳丸浩の日記 http://blog.tokumaru.org/2013/12/php_21.html

…かっ、被りました。ネタが被りました。
しかも某方面お大御所の徳丸さんの記事です。
私が紹介したかった内容の半分以上はこの記事の内容の通りです!
おかげ様でシェル介在による OS コマンドインジェクションの説明や代表的な回避方法、
PHP 方面の調査の手間が省けて助かりました(泣。
お薦めの記事なので是非読みましょう。

なになにー?

> \*2 例外として、pcntl_fork および pcntl_exec
> を使ってコマンドを呼び出すと シェル経由にはなりませんが、
> PCNTL関数の制限としてCGI版PHPを使わなければならないため、
> 通常のWebアプリケーションで利用するのは現実的ではありません。 

えっ?!

ええっ?!!!

何その欠陥。

PHP…おそろしい子！

…

閑話休題。以下、徳丸さんの記事と被っている点はご容赦を。

事の発端
----------------------------------------------------------------------

そもそもは、
私の TL を賑せていた文字エスケープの話題にシェル関係の話が出てきたので、
少し突っ込みを入れてみたいと思い、この記事を書こうと思い立ちました。

そんな中で目にした Blog 記事:

  * OSコマンドのエスケープ | yohgaki's blog
    * http://blog.ohgaki.net/os-command-escape
  * OSコマンドのエスケープ – シェルの仕様とコマンドの実装 | yohgaki's blog
    * http://blog.ohgaki.net/os-command-escape-shell-spec-command-implementation

「えすけーぷじゅうよう!!」を強調して言いたいからなのかシェルの理解が足りないからなのか、
意図がよくわからない文言やら説明が散見されますが、きりがないのでそれらはスルーします。
(なんで tcsh の話が出てくるんだとか)

特に気になったのが以下の文章です。(強調は私によるもの)

> *OSコマンドはOSが提供するシェルで実行されます*。
> シェルはテキストインターフェースを持ち、
> テキストでコマンドとオプションを受け取り実行します。
> 例示した脆弱なPHPプログラムの場合、
> ユーザーからの入力に対しセキュリティ処理を一切してないため、
> 簡単にサーバーを乗っ取られる可能性があります。

「小難しい(?)シェルのメタ文字エスケープだけでなく、シェルを介さない OS
コマンド起動方法も紹介すればいいじゃん」と思って記事を書き始めたわけですが、
この Blog を書かれた方は PHP 専門らしく、しかも PHP ではシェルを介さない
OS コマンド実行ができない欠陥がある (条件に依るが）ので仕方ないのかもしれません。

OS コマンドの実行方法
----------------------------------------------------------------------

あるプログラム(プロセス)から外部の OS コマンドを実行するには、
単純に起動するだけでも次のような手順が必要です。少し面倒ですね。

  1. プロセスを生成する。(`fork`(2))
  2. 子プロセスが実行したいコマンドを起動する(成り代る)。 (`exec`(2))
  3. 親プロセスは子プロセスが終了するのを待ち、
     子プロセスの終了コード (0〜255 の数値)と終了要因(`exit`(2)
     したかシグナルを受けたか)を得る。(`wait`(2))

これ以外にも、コマンドの引数の準備や環境変数の設定、
コマンドの入力元(標準入力)と出力先(標準出力と標準エラー出力)の調整、
複数コマンドの組み合せや親プロセスとの通信(パイプライン、IPC)など、
要件に依ってはかなり面倒になります。

手軽な OS コマンド起動 API `system`(3) とその仲間たち
----------------------------------------------------------------------

あなたの身近なところに OS コマンドを実行するのに非常に便利なものがあります。
それは何でしょうか? そう、シェルですね!
もともとシェルは、ユーザーと OS との橋渡しをするためのプログラムとして誕生しました
(要出典)。
普段、シェルを利用している人は、
シェルのおかげで息を吐くようにコマンドを実行していることと思います。

そのシェルを介してコマンドを起動するための API が `system`(3) です。
`system`(3) は C の関数です。
シェルを対話的に利用しているときと同様に、
C のプログラムから手軽にコマンドを実行することができます。

C 以外の各種言語にも `system`(3) と同名あるいは同等の API が用意されています。

  * Ruby
    * `system()` など。
  * Perl
    * `system()` など。
  * Python
    * `os.system()` など。
  * PHP
    * `system()` など。
  * Go
    * ありません! (たぶん。調査足りてないかも)
    * むしろなくて正解。
    * どうしてもシェルを利用したければふつうの手順で `/bin/sh` を起動すればよい。

`system`(3) の問題点 (= シェルの仕様の理解不足 != シェルの問題点)
----------------------------------------------------------------------

`system`(3) の利点であり時に欠点となるのがシェルによる柔軟さです。
シェルはもともと対人用に作成された経緯もあり(要出典)、
シェルが受け付けるコマンドラインはかなり自由に書けます。

シェルとの対話に慣れた人であれば、シェルと対話(コマンド入力)するとき、
あまり細かいことを意識せずにコマンド名、オプション、そのほか引数を入力し、
必要であればシェルの特殊文字(メタ文字)をエスケープしていることでしょう。
しかし、シェルをプログラムから利用する場合はどうでしょうか。
あなたの書いたプログラムは、あなたの期待するコマンド名、オプション、引数を、
ちゃんとシェルに伝えられていますか?
それができるほど、シェルのことを理解していますか?

シェルのことをよく理解していたとしても、
`system`(3) の安全・確実な使用は困難です。
シェルのコマンドラインをシェルからシェルを介して実行することの困難さを想像すればわかるでしょう。

``` console
$ /bin/sh -c 'コマンドライン'
```

…抽象的で具体例がなくてすみません(気が向いたら後で追記します)。
わかりやすい具体例は[徳丸さんの Blog](http://blog.tokumaru.org/2013/12/php_21.html)
をどうぞ。

シェルの介在を無くす
----------------------------------------------------------------------

*まだ執筆途中。*

駄目な例:

``` console
$ cat print-args-buggy.pl
#!/usr/bin/perl
system("printf '%s\n' @ARGV");
$ perl print-args-buggy.pl foo bar
```

``` sh
#!/bin/sh
fmt='%s\n'
printf $cmd $fmt $@
exit $?
```

よい例:

``` ruby
#!/usr/bin/ruby
cmdline = ['printf', '%s\n', *ARGV]
ret = system([cmdline[0], cmdline[0]], *cmdline[1..-1])
exit($?.exitstatus)
```

``` perl
#!/usr/bin/perl
use strict;
use warnings;
use POSIX;
my @cmdline = ('printf', '%s\n', @ARGV);
my $cmdstatus = system {$cmdline[0]} @cmdline;
exit(POSIX::WEXITSTATUS($cmdstatus));
```

``` python
#!/usr/bin/python
import sys
import os
cmdline = ['printf', '%s\n'] + sys.argv[1:]
sys.exit(os.spawnvp(os.P_WAIT, cmdline[0], cmdline))
```

``` sh
#!/bin/sh
set -u
cmd='printf'
set -- '%s\n' "$@"
command "$cmd" "$@"
exit $?
```

それでもシェルが利用したいときは?
----------------------------------------------------------------------

執筆中…。近日公開。

* * *

{% include wishlist-dec.html %}

